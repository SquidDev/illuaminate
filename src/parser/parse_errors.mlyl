{
  let is_same_line prev token =
    match token with
    | Grammar.EOF _ -> false
    | _ -> prev.Lexing.pos_lnum = IlluaminateCore.Span.start_line (Token.get_span token)

  let span_after lines (pos : Lexing.position) =
    IlluaminateCore.Span.of_pos2 lines pos { pos with pos_cnum = pos.pos_cnum + 1 }

  let line_end_position lines prev token =
    if is_same_line prev token then Token.get_span token else span_after lines prev
}

rule error_message lines = parse error

(* Match `expr() =` in tables: probably wanted `[expr()] = ...` *)
| [_ / table_entry: expr . ...]
  partial {
    match token with
    | Grammar.EQUALS _ -> Some (Error.Table_key_equals token)
    | _ -> None
  }

(* Match `expr() = ` in any other context: probably wanted `expr() == `. *)
| [expr]
  partial {
    match token with
    | EQUALS _ -> Some (Error.Use_double_equals token)
    | _ -> None
  }

(* Suggest a missing comma in table entries. *)
| last = [_ / table_body: table_entry . ...]
  partial {
    match token with
    | STRING _ | NUMBER _ | INT _ | MNUMBER _ | TRUE _ | FALSE _ | NIL _
      -> Some (Missing_table_comma { comma_pos = span_after lines $endloc(last); token })
    | _ -> None
  }

(* Suggest removing a comma in function calls. *)
| (_ / call_args: OPAREN . ...);
  (expr | COMMA)* ;
  (comma = COMMA / sep_list1(COMMA,expr): expr COMMA . sep_list1(COMMA,expr) ...)
  partial {
    match token with
    | CPAREN _ -> Some (Trailing_call_comma { comma = comma; token })
    | _ -> None
  }

(* Unclosed parentheses. *)
| open_ = OPAREN; [_ / ... . CPAREN]
| open_ = OBRACE; [_ / ... . CBRACE]
| open_ = OSQUARE; [_ / ... . CSQUARE]
  { Unclosed_brackets { open_; token } }
| start = DOUBLE_COLON; [_ / stmt: DOUBLE_COLON ident . DOUBLE_COLON]
  { Unfinished_label { start; token } }

(* `local function x.f() end` *)
| local = LOCAL; FUNCTION; [var]
  partial {
    match token with
    | DOT _ -> Some (Local_function_dot { local; token })
    | _ -> None
  }

(* A standalone name in a statement context *)
| x = [sep_list1(COMMA,name)]
  {
    if is_same_line $endloc(x) token then
      Standalone_name token
    else
      Standalone_name_call (span_after lines $endloc(x))
  }

(* An `if`/`elseif` statement with a missing `then`. *)
| (if_ = IF | if_ = ELSEIF); expr = [expr]
  { Expected_then { if_; pos = line_end_position lines $endloc(expr) token } }

(* Statements with a missing `end`. *)
| (start = IF | start = ELSEIF) ; expr ; THEN; [stmts]
| start = ELSE ; [stmts]
| start = WHILE ; expr ; DO; [stmts]
| (start = DO / stmt: DO . ...) ; [stmts]
| (start = FUNCTION / stmt: FUNCTION . ...) ; function_name; [args ; stmts]
| (start = FUNCTION / atom: FUNCTION . ...) ; [args ; stmts]
  { Expected_end { start = IlluaminateCore.Node.span start; token } }

(* We handle local function specially, to capture both loc and func. *)
| loc = LOCAL; func = FUNCTION; var; [args ; stmts]
  {
    let start = IlluaminateCore.Span.of_span2
      (IlluaminateCore.Node.span loc)
      (IlluaminateCore.Node.span func)
    in
    Expected_end { start; token } }

(* Fallback parse error for when we expected a statement. *)
| [_ / stmts: ... . ...]
  partial {
    match token with
    | END _ -> Some (Unexpected_end token)
    | EOF _ -> None
    | _ -> Some (Expected_statement token)
  }

(* Fallback parse error for function arguments. *)
| [_? / ... . args ...]
  { Expected_function_args token }

(* Fallback parse error for when we expected an expression. *)
| [/ ... . expr ...] | [/ ... . expr_pow ...] | [/ ... . sep_list1(COMMA,expr) ...]
  { Expected_expression token }

(* Fallback parse error for when we expected a variable name. *)
| [/ ... . var ...] | [/ ... . name ...] | [_ / ... . function_name ...]
  { Expected_var token }
